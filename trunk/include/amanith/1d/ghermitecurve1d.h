/****************************************************************************
** $file: amanith/1d/ghermitecurve1d.h   0.1.0.0   edited Jun 30 08:00
**
** 1D Hermite curve segment definition.
**
**
** Copyright (C) 2004-2005 Mazatech Inc. All rights reserved.
**
** This file is part of Amanith Framework.
**
** This file may be distributed and/or modified under the terms of the Q Public License
** as defined by Mazatech Inc. of Italy and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees holding valid Amanith Professional Edition license may use this file in
** accordance with the Amanith Commercial License Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.mazatech.com or email sales@mazatech.com for
** information about Amanith Commercial License Agreements.
** See http://www.amanith.org/ for opensource version, public forums and news.
**
** Contact info@mazatech.com if any conditions of this licensing are
** not clear to you.
**********************************************************************/

#ifndef GHERMITECURVE1D_H
#define GHERMITECURVE1D_H

/*!
	\file ghermitecurve1d.h
	\brief Header file for 1D Hermite multicurve class.
*/

#include "amanith/1d/gmulticurve1d.h"
#include "amanith/1d/gbeziercurve1d.h"

namespace Amanith {


	// *********************************************************************
	//                           GHermiteCurve1D
	// *********************************************************************
	
	//! GHermiteCurve1D static class descriptor.
	static const GClassID G_HERMITECURVE1D_CLASSID = GClassID("GHermiteCurve1D", 0x3B5F03EB, 0x68B14C3A, 0x85188E50, 0x463A5DFE);

	/*!
		\struct GHermiteKey1D
		\brief 1D Hermite key structure.

		This structure represents an 1D Hermite key. The key is described by its domain parameter, point position, incoming
		tangent and outcoming tangent.
	*/
	struct GHermiteKey1D {
		//! Domain parameter.
		GReal Parameter;
		//! Key value, a 1D geometric point.
		GReal Value;
		//! Incoming tangent value.
		GReal InTangent;
		//! Outcoming tangent value.
		GReal OutTangent;

		//! Default constructor, set domain parameter at 0, point value at origin, and null tangents.
		GHermiteKey1D() {
			Parameter = 0;
			Value = InTangent = OutTangent = 0;
		}
		//! Set constructor, specifying domain parameter and key point; tangents are set to null values.
		GHermiteKey1D(const GReal _Parameter, const GReal _Value) : Parameter(_Parameter), Value(_Value) {
			InTangent = OutTangent = 0;
		}
		//! Set constructor, specifying all data.
		GHermiteKey1D(const GReal _Parameter, const GReal _Value, const GReal _InTangent,
					  const GReal _OutTangent) : Parameter(_Parameter), Value(_Value), InTangent(_InTangent),
					  OutTangent(_OutTangent) {
		}
		//! Copy constructor.
		GHermiteKey1D(const GHermiteKey1D& Source) {
			Parameter = Source.Parameter;
			Value = Source.Value;
			InTangent = Source.InTangent;
			OutTangent = Source.OutTangent;
		}
		//! Assignment operator.
		GHermiteKey1D& operator =(const GHermiteKey1D& Source) {
			Parameter = Source.Parameter;
			Value = Source.Value;
			InTangent = Source.InTangent;
			OutTangent = Source.OutTangent;
			return *this;
		}
	};


	/*!
		\class GHermiteCurve1D
		\brief This class implements a 1D Hermite multicurve.

		An Hermite multicurve is a curve made of Hermite traits. An Hermite trait is a parametric cubic curve, defined
		by two points and two tangent vectors, as you can see in the image below.
		\image html herm_trait.gif "Hermite trait example"

		This kind of curve is called 'cardinal', it interpolates the two point and the two tangents. From P0's point
		of view, T0 is called 'outcoming' tangent. From P1's point of view, T1 is called 'incoming' tangent.
	*/
	class G_EXPORT GHermiteCurve1D : public GMultiCurve1D {

	private:
		struct GHermiteCallBackData {
			const GHermiteCurve1D* Curve;
			GUInt32 KeyIndex;
			// constructor
			GHermiteCallBackData(const GHermiteCurve1D *_Curve, const GUInt32 _KeyIndex) {
				Curve = _Curve;
				KeyIndex = _KeyIndex;
			}
		};

		//! Array of Hermite keys that build the curve.
		GDynArray<GHermiteKey1D> gKeys;

	protected:
		//! Sort keys, in ascending order respect to domain parameters.
		void SortKeys();
		//! Cloning function, copies (physically) a Source Hermite curve into this curve.
		GError BaseClone(const GElement& Source);
		/*!
			Curve subdivision.

			Cuts the curve at specified parameter, and return left and right Hermite arcs.

			\param u domain parameter specifying where to cut the curve.
			\param RightCurve if non-NULL, the function must return the right arc generated by cutting operation.
			\param LeftCurve if non-NULL, the function must return the left arc generated by cutting operation.
			\note The domain parameter is ensured to be completely inside the curve domain. Furthermore RightCurve and
			LeftCurve parameters, if specified, are ensured to be GHermiteCurve1D classes (so cast is type-safe).
		*/
		GError DoCut(const GReal u, GCurve1D *RightCurve, GCurve1D *LeftCurve) const;
		/*!
			Add a new (key)point for the curve.

			\param Parameter the domain parameter where to add the (key)point.
			\param NewPoint if not specified (NULL value) the point is created on curve. In this case the specified
			domain Parameter must reside completely inside the domain, else an G_OUT_OF_RANGE error is returned.
			If Newpoint is specified (non NULL) the point is created also outside domain range.
			\param Index the position (internal index) occupied by the created (key)point.
			\param AlreadyExists a G_TRUE value means that the point has been created at a domain position already occupied
			by another (key)point. In this case the already existing point is overridden by the created point.
			\return G_NO_ERROR if the function succeeds, an error code otherwise.
		*/
		GError DoAddPoint(const GReal Parameter, const GReal *NewPoint, GUInt32& Index, GBool& AlreadyExists);
		/*!
			Remove a (key)point from the curve.
			Index is ensured to be valid and we are sure that after removing we'll have (at least) a minimal
			(2-(key)points made) multi-curve.

			\param Index the index of (key)point to be removed. Note that this value is ensured to be always valid.
			\return G_NO_ERROR if the function succeeds, an error code must be returned otherwise.
		*/
		GError DoRemovePoint(const GUInt32 Index);
		/*!
			Calculate tangents using Catmull-Rom schema.
			
			\param Index0 the lower key index, where to begin to calculate tangents.
			\param Index1 the upper key index, where to end to calculate tangents.
		*/
		void CalcCatmullRomTangents(const GUInt32 Index0, const GUInt32 Index1);
		/*!
			Calculate the length of the Index-th Hermite trait, specifying a trait's subdomain range.
		*/
		GReal SegmentLength(const GUInt32 Index, const GReal MinParam, const GReal MaxParam,
							const GReal MaxError) const;
		/*!
			Calculate the curve value for a specified Index-th Hermite trait. The passed domain parameter must
			reside inside the trait's subdomain.
		*/
		GReal SegmentEvaluate(const GUInt32 Index, const GReal Parameter) const;
		/*!
			Calculate the curve derivative for a specified Index-th Hermite trait. The passed domain parameter must
			reside inside the trait's subdomain. The order of derivative is specified through Order parameter.
		*/
		GReal SegmentDerivative(const GUInt32 Index, const GDerivativeOrder Order, const GReal Parameter) const;

		GReal SegmentTangent(const GUInt32 Index, const GDerivativeOrder Order, const GReal Parameter) const;
		/*!
			This method do the actual Bezier conversion.

			\param Index the Hermite trait index to be converted. It must be valid.
			\param Result the resulting Bezier curve.
			\return G_NO_ERROR in operation succeeds, an error code otherwise.
		*/
		void SegmentToBezierConversion(const GUInt32 Index, GBezierCurve1D& Result) const;
		// static speed evaluation callback (useful for length evaluation)
		static GReal SegmentSpeedEvaluationCallBack(const GReal u, void *Data);
		/*!
			Get domain parameter corresponding to specified (key)point index.
			Index is ensured to be valid.

			\param Index the point index, is ensured to be always valid.
			\param Parameter the outputted domain parameter, corresponding to the specified (key)point index.
			\return G_NO_ERROR if the function succeeds, an error code must be returned otherwise.
		*/
		GError DoGetPointParameter(const GUInt32 Index, GReal& Parameter) const;
		/*!
			Set domain parameter corresponding to specified (key)point index. The final effect is that a (key)point
			is moved from its domain position to another domain position.

			\param Index the point index, is ensured to be always valid.
			\param NewParamValue the new domain parameter, where to move the specified (key)point. It can be outside
			current domain.
			\param NewIndex the new position (internal index) occupied by the moved (key)point. This method outputs
			this value.
			\param AlreadyExists this method writes to this flag a G_TRUE value if the point has been
			moved in a domain position already occupied by another (key)point. In this case the already existing
			point is overridden by the moved point.
			\return G_NO_ERROR if the function succeeds, an error code otherwise.
		*/
		GError DoSetPointParameter(const GUInt32 Index, const GReal NewParamValue,
								   GUInt32& NewIndex, GBool& AlreadyExists);

	public:
		//! Default constructor, constructs and empty Hermite curve.
		GHermiteCurve1D();
		//! Constructor with kernel specification, constructs and empty Hermite curve.
		GHermiteCurve1D(const GElement* Owner);
		//! Destructor, free all keys and other internal structures.
		~GHermiteCurve1D();
		//! Clear the curve (remove keys, free internal structures and set an empty domain).
		void Clear();
		//! Returns number of key points.
		inline GUInt32 PointsCount() const {
			return (GUInt32)gKeys.size();
		}
		/*!
		Given a domain value, it returns the span index that includes it.

		\param Param the domain parameter
		\param KeyIndex the lower key index of the interval where Param is included. Param is contained
		in the interval [KeyIndex, KeyIndex+1)
		\return G_TRUE if the domain value is inside the current domain, G_FALSE otherwise.
		\note if Param is equal to DomainEnd(), then the index KeyIndex+1 is not valid. So you must
		check this case before calling ParamToKeyIndex.
		*/
		GBool ParamToKeyIndex(const GReal Param, GUInt32& KeyIndex) const;
		//! Get Index-th key point; Index must be valid, else a point with infinitive component is returned.
		GReal Point(const GUInt32 Index) const;
		//! Set Index-th (key)point; Index must be valid.
		GError SetPoint(const GUInt32 Index, const GReal NewPoint);
		/*!
			Construct a new Hermite curve, specifying just interpolated (key)points.
			Key tangents will be calculated using a Catmull-Rom schema.

			\param NewPoints the array of points of the curve. Each point will be interpolated (Hermite curves
			passes through key points).
			\param NewMinValue the lower bound of the curve domain.
			\param NewMaxValue the upper bound of the curve domain.
			\param Uniform if G_TRUE, keys will be generated uniformly (spanning the new domain uniformly). If G_FALSE
			keys position will be calculated using length of each Hermite trait.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
		*/
		GError SetPoints(const GDynArray<GReal>& NewPoints,
						 const GReal NewMinValue, const GReal NewMaxValue, const GBool Uniform = G_FALSE);
		/*!
			Get a key, specifying its index.

			\param Index the index of the key to be retrieved.
			\param KeyValue the variable where the requested key will be outputted.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
		*/
		GError Key(const GUInt32 Index, GHermiteKey1D& KeyValue) const;
		//! Get the internal keys array.
		const GDynArray<GHermiteKey1D>& Keys() const {
			return gKeys;
		}
		/*!
			Build the Hermite curve, specifying keys.

			\param NewKeys the keys that will constitute the curve. Can be unsorted by domain values.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
			\note The specified keys array must contain at least 2 keys, else a G_INVALID_PARAMETER error code will be
			returned.
		*/
		GError SetKeys(const GDynArray<GHermiteKey1D>& NewKeys);
		/*!
			Set a new geometric value.

			\param Index the index of the key we want to set. Must be valid.
			\param NewKeyValue the new point value.
			\param InTangent the new incoming tangent value.
			\param OutTangent the new outcoming tangent value.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
		*/
		GError SetKey(const GUInt32 Index, const GReal NewKeyValue, const GReal InTangent, const GReal OutTangent);
		/*
			Add a key to the curve.

			\param NewKey the key to add.
			\param InsertedIndex the index (into the internal keys array) where the key has been inserted.
			\param AlreadyExists a G_TRUE value means that the added key has overridden an already existing key, because
			they occupied the same domain position.
		
		GError AddKey(const GHermiteKey1D& NewKey, GUInt32& InsertedIndex, GBool& AlreadyExists);*/

		/*!
			Set curve domain.

			All (key)points domain positions will be scaled and shifted to respect the new domain.
			The reparametrized curve is geometrically the same curve but parametrically it is different. In particular
			internal knots (key domain values) are scale/shifted, and derivatives module (magnitudes) are scaled
			too.

			\param NewMinValue the lower bound of the new domain.
			\param NewMaxValue the upper bound of the new domain.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
			\note if NewMinValue is greater than NewMaxValue they will be swapped, so any combination of values is valid.
		*/
		GError SetDomain(const GReal NewMinValue, const GReal NewMaxValue);
		/*!
			Returns the length of the curve between the 2 specified global domain values.

			The implementation take care of every Hermite trait. Because at each key point the curve can be (in general)
			only continuous (and not differentiable), we must calculate the length as the sum of single interested
			Hermite traits length.

			\param u0 the lower bound of integral
			\param u1 the upper bound of integral
			\param MaxError the maximum relative error (precision) at witch we wanna calculate length.
			\return The length of curve, calculated in the domain interval [u0; u1].
			\note Before integration, the specified interval is checked and clamped to be be valid for this curve domain.
		*/
		GReal Length(const GReal u0, const GReal u1, const GReal MaxError = G_EPSILON) const;
		/*! 
			Return the curve value calculated at specified domain parameter.

			\param u the domain parameter at witch we wanna evaluate curve value.
			\note if specified domain parameter is out of domain, StartPoint() or EndPoint() are returned (depending of
			witch side the parameter is out).
		*/
		GReal Evaluate(const GReal u) const;
		/*!
			Return the curve derivative calculated at specified domain parameter.

			\param Order the order of derivative.
			\param u the domain parameter at witch we wanna evaluate curve derivative.
			\note specified domain parameter is clamped by domain interval.
		*/
		GReal Derivative(const GDerivativeOrder Order, const GReal u) const;
		/*!
			Return the curve derivative calculated at specified domain parameter. This method differs from
			the one of base GCurve1D class in the number of returned values. This is due to the possibility
			that the curve is continuous but not derivable (in the sense that left and right derivatives
			are different).

			\param Order the order of derivative.
			\param u the domain parameter at witch we wanna evaluate curve derivative.
			\param LeftDerivative the left derivative.
			\param RightDerivative the right derivative.
			\note specified domain parameter is clamped by domain interval.
		*/
		void DerivativeLR(const GDerivativeOrder Order, const GReal u,
						  GReal& LeftDerivative, GReal& RightDerivative) const;
		/*!
			Hermite to cubic Bezier conversion.

			This method converts an Hermite trait into an equivalent cubic Bezier representation. The conversion can be
			easily derived equaling their power series representations.

			\param Index the Hermite trait index to be converted (the trait will be the one defined by (key)points
			Index and Index+1). It must be valid.
			\param Result the resulting Bezier curve.
			\return G_NO_ERROR in operation succeeds, an error code otherwise.
		*/
		GError SegmentToBezier(const GUInt32 Index, GBezierCurve1D& Result);
		/*!
			Scale all curve points around a pivot point. This member has been overridden to take care of
			tangents too.

			\param Pivot the pivot point (the center of scaling).
			\param ScaleAmount the scale factor.
		*/
		void Scale(const GReal Pivot, const GReal ScaleAmount);
		//! Get class descriptor.
		inline const GClassID& ClassID() const {
			return G_HERMITECURVE1D_CLASSID;
		}
		//! Get base class (father class) descriptor.
		inline const GClassID& DerivedClassID() const {
			return G_MULTICURVE1D_CLASSID;
		}
	};


	// *********************************************************************
	//                        GHermiteCurve1DProxy
	// *********************************************************************

	/*!
		\class GHermiteCurve1DProxy
		\brief This class implements a GHermiteCurve1D proxy (provider).

		This proxy provides the creation of GHermiteCurve1D class instances.
	*/
	class G_EXPORT GHermiteCurve1DProxy : public GElementProxy {
	public:
		//! Creates a new GHermiteCurve1D instance
		GElement* CreateNew(const GElement* Owner = NULL) const {
			return new GHermiteCurve1D(Owner);
		}
		//! Get class descriptor of elements type "provided" by this proxy.
		const GClassID& ClassID() const {
			return G_HERMITECURVE1D_CLASSID;
		}
		//! Get base class (father class) descriptor of elements type "provided" by this proxy.
		const GClassID& DerivedClassID() const {
			return G_MULTICURVE1D_CLASSID;
		}
	};
	//! Static proxy for GHermiteCurve1D class.
	static const GHermiteCurve1DProxy G_HERMITECURVE1D_PROXY;

};	// end namespace Amanith

#endif
