/****************************************************************************
** $file: amanith/1d/gbezcurve1d.h   0.1.0.0   edited Jun 30 08:00
**
** 1D Bezier curve segment definition.
**
**
** Copyright (C) 2004-2005 Mazatech Inc. All rights reserved.
**
** This file is part of Amanith Framework.
**
** This file may be distributed and/or modified under the terms of the Q Public License
** as defined by Mazatech Inc. of Italy and appearing in the file
** LICENSE.QPL included in the packaging of this file.
**
** Licensees holding valid Amanith Professional Edition license may use this file in
** accordance with the Amanith Commercial License Agreement provided with the Software.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.mazatech.com or email sales@mazatech.com for
** information about Amanith Commercial License Agreements.
** See http://www.amanith.org/ for opensource version, public forums and news.
**
** Contact info@mazatech.com if any conditions of this licensing are
** not clear to you.
**********************************************************************/

#ifndef GBEZIERCURVE1D_H
#define GBEZIERCURVE1D_H

/*!
	\file gbeziercurve1d.h
	\brief Header file for 1D Bezier curve class.
*/

#include "amanith/1d/gcurve1d.h"

namespace Amanith {


	class GHermiteCurve1D;

	// *********************************************************************
	//                             GBezierCurve1D
	// *********************************************************************

	//! GBezierCurve1D static class descriptor.
	static const GClassID G_BEZIERCURVE1D_CLASSID = GClassID("GBezierCurve1D", 0x29C42AAE, 0xC8DE43DE, 0xB980A2C5, 0xB15409B0);

	/*!
		\class GBezierCurve1D
		\brief A generic degree 1D Bezier curve.

		Originally developed by Pierre Bezier in the 1970's for CAD/CAM operations, this kind of parametric curves is
		very famous soon (for example, they are the underpinnings of the entire Adobe PostScript drawing model).
		The Bezier curve is a parametric function of N points; two endpoints and N-2 'internal' control points. The curve
		connects the endpoints, but doesn't necessarily touch other control points. The general form Bezier equation, which
		describes each point on the curve as a function of domain parameter t, is:

		\f[
			C(t) = \sum_{i=0}^{N} B_{i, N}(t)P_{i}
		\f]

		with the Bernstein basis polynomials defined as:

		\f[
		B_{i, N}(t) = \left( \begin {array}{c}
		N \\
		i \end{array} \right) t^{i}(1-t)^{N-i}
		\f]

		Bezier curves are widely used in computer graphics to model smooth curves. As the curve is completely contained
		in the convex hull of its control points, the points can be graphically displayed and used to manipulate the
		curve intuitively. Affine transformations such as translation, scaling and rotation can be applied on the curve
		by applying the respective transform on the control points of the curve.\n
		The most important Bezier curves are quadratic and cubic curves. Higher degree curves are more expensive to
		evaluate and there is no analytic formula to calculate the roots of polynomials of degree 5 and higher.\n
		Like other Amanith curves, Bezier curves can be flattened using squared chordal distance threshold, and two
		optimized non-recursive flattening schemes were implemented for quadratics and cubics Bezier curves. These optimized
		versions are terrible fast and produce about 34% less segments than classic recursive schemes.
		
		For more details about Bezier curve, please check this
		site: http://astronomy.swin.edu.au/~pbourke/curves/bezier/
	*/
	class G_EXPORT GBezierCurve1D : public GCurve1D {

	private:
		//! Control points
		GDynArray<GReal> gPoints;
		//! Dynamic array, containing first order forward differences.
		mutable GDynArray<GReal> gForwDiff1;
		//! Dynamic array, containing second order forward differences.
		mutable GDynArray<GReal> gForwDiff2;
		//! Modify flag: it signs if a control point (or domain) has been modified (so forward differences must be
		// recalculated when calling derivatives estimation)
		mutable GBool gModified;

		//! Calculate first and second order forward differences
		void BuildForwDiff() const;

	protected:
		//! Cloning function, copies (physically) a Source Bezier curve into this curve.
		GError BaseClone(const GElement& Source);
		/*!
			Curve subdivision.

			Cuts the curve at specified parameter, and return left and right Bezier arcs.

			\param u domain parameter specifying where to cut the curve.
			\param RightCurve if non-NULL, the function must return the right arc generated by cutting operation.
			\param LeftCurve if non-NULL, the function must return the left arc generated by cutting operation.
			\note The domain parameter is ensured to be completely inside the curve domain. Furthermore RightCurve and
			LeftCurve parameters, if specified, are ensured to be GBezierCurve1D classes (so cast is type-safe).
		*/
		GError DoCut(const GReal u, GCurve1D *RightCurve, GCurve1D *LeftCurve) const;

	public:
		//! Default constructor, creates an empty Bezier.
		GBezierCurve1D();
		//! Constructor with owner (kernel) parameter, creates an empty Bezier.
		GBezierCurve1D(const GElement* Owner);
		//! Destructor
		virtual ~GBezierCurve1D();
		//! Clear the curve (remove control points, free internal structures and set an empty domain).
		void Clear();
		//! Returns number of control points.
		GUInt32 PointsCount() const;
		//! Get curve degree; this value is equal to PointsCount() - 1.
		GInt32 Degree() const;
		//! Get control points array.
		const GDynArray<GReal>& Points() const {
			return gPoints;
		}
		//! Get Index-th control point; Index must be valid, else a point with infinitive components is returned.
		GReal Point(const GUInt32 Index) const;
		//! Set Index-th control point; Index must be valid.
		GError SetPoint(const GUInt32 Index, const GReal NewPoint);
		/*!
			Build the Bezier curve, specifying control points. This is the only method to build a Bezier curve.

			The curve will have a (|NewPoints| - 1) degree.
			\param NewPoints control points that will build this Bezier curve. At least two points must be specified, else
			curve can't be built.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
			\note Domain won't be changed.
		*/
		GError SetPoints(const GDynArray<GReal>& NewPoints);
		/*!
			Build a quadratic Bezier curve, specifying its three control points.
			This method is provided for convenience.

			\note Domain won't be changed.
		*/
		GError SetPoints(const GReal P0, const GReal P1, const GReal P2);
		/*!
			Build a cubic Bezier curve, specifying its four control points.
			This method is provided for convenience.

			\note Domain won't be changed.
		*/
		GError SetPoints(const GReal P0, const GReal P1, const GReal P2, const GReal P3);
		/*!
			Set curve domain, and sign this Bezier curve as modified.

			\param NewMinValue the lower bound of the new domain.
			\param NewMaxValue the upper bound of the new domain.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
			\note if NewMinValue is greater than NewMaxValue they will be swapped, so any combination of values is valid.
		*/
		GError SetDomain(const GReal NewMinValue, const GReal NewMaxValue);
		/*!
			Increases by one the degree of the curve (without changing its shape).

			More details about Bezier degree elevation can be found
			here: http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-elev.html

			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
		*/
		GError HigherDegree();
		/*!
			Increases by HowManyTimes the degree of the curve (without changing its shape).

			More details about Bezier degree elevation can be found
			here: http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-elev.html

			\param HowManyTimes the degree elevation amount.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
			\note this an "ad hoc" implementation, it does not call HowManyTimes times the HigherDegree() function.
		*/
		GError HigherDegree(const GInt32 HowManyTimes);
		/*!
			Increases by one the degree of the curve (without changing its shape), and put the result into the
			specified output Bezier curve.

			More details about Bezier degree elevation can be found
			here: http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-elev.html

			\param OutputCurve the curve used as destination.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
		*/
		GError HigherDegree(GBezierCurve1D& OutputCurve) const;

		/*!
			Increases by HowManyTimes the degree of the curve (without changing its shape), and put the result into the
			specified output Bezier curve.

			More details about Bezier degree elevation can be found
			here: http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-elev.html

			\param HowManyTimes the degree elevation amount.
			\param OutputCurve the curve used as destination.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
			\note this an "ad hoc" implementation, it does not call HowManyTimes times the HigherDegree() function.
		*/
		GError HigherDegree(const GInt32 HowManyTimes, GBezierCurve1D& OutputCurve) const;

		/*!
			Decreases by one the degree of the curve.

			The algorithm implemented is an interesting variation of the classical odd/even points extrapolation.
			Our idea is completely original, and shows better results.
			For more details about Bezier degree reduction can be found
			here: http://anziamj.austms.org.au/V36/part4/park/p399.html

			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
		*/
		GError LowerDegree();
		/*!
			Decreases by one the degree of the curve, and put the result into the specified output Bezier curve.

			The algorithm implemented is an interesting variation of the classical odd/even points extrapolation.
			Our idea is completely original, and shows better results.
			For more details about Bezier degree reduction can be found
			here: http://anziamj.austms.org.au/V36/part4/park/p399.html

			\param OutputCurve the curve used as destination.
			\return G_NO_ERROR if the operation succeeds, an error code otherwise.
		*/
		GError LowerDegree(GBezierCurve1D& OutputCurve) const;
		/*! 
			Return the curve value calculated at specified domain parameter.

			\param u the domain parameter at witch we wanna evaluate curve value.
			\note if specified domain parameter is out of domain, StartPoint() or EndPoint() are returned (depending of
			witch side the parameter is out).
		*/
		GReal Evaluate(const GReal u) const;
		/*!
			Return the curve derivative calculated at specified domain parameter.

			\param Order the order of derivative.
			\param u the domain parameter at witch we wanna evaluate curve derivative.
			\note specified domain parameter is clamped by domain interval.
		*/
		GReal Derivative(const GDerivativeOrder Order, const GReal u) const;
		/*!
			Cubic Bezier to Hermite conversion.

			This method converts a cubic Bezier trait into an Hermite representation. The conversion can be
			easily derived equaling their power series representations.

			\return G_NO_ERROR in operation succeeds, an error code otherwise.
			\note if this Bezier curve is not cubic an G_INVALID_OPERATION error code is returned.
		*/
		GError ConvertToHermite(GHermiteCurve1D& Curve) const;
		//! Get class descriptor.
		inline const GClassID& ClassID() const {
			return G_BEZIERCURVE1D_CLASSID;
		}
		//! Get base class (father class) descriptor.
		inline const GClassID& DerivedClassID() const {
			return G_CURVE1D_CLASSID;
		}
	};


	// *********************************************************************
	//                           GBezierCurve1DProxy
	// *********************************************************************

	/*!
		\class GBezierCurve1DProxy
		\brief This class implements a GBezierCurve1D proxy (provider).

		This proxy provides the creation of GBezierCurve1D class instances.
	*/
	class G_EXPORT GBezierCurve1DProxy : public GElementProxy {
	public:
		//! Creates a new GBezierCurve1D instance
		GElement* CreateNew(const GElement* Owner = NULL) const {
			return new GBezierCurve1D(Owner);
		}
		//! Get class descriptor of elements type "provided" by this proxy.
		const GClassID& ClassID() const {
			return G_BEZIERCURVE1D_CLASSID;
		}
		//! Get base class (father class) descriptor of elements type "provided" by this proxy.
		const GClassID& DerivedClassID() const {
			return G_CURVE1D_CLASSID;
		}
	};
	//! Static proxy for GBezierCurve1D class.
	static const GBezierCurve1DProxy G_BEZIERCURVE1D_PROXY;

};	// end namespace Amanith

#endif
